name: Deploy GitOps Image
description: >
  Actualiza el tag de una imagen en el repo de GitOps (staging o prod) leyendo el
  comando `deploy -t <tag> -e <env>` desde un comentario de PR y sube los cambios
  al repositorio GitOps mediante una PR automática.
inputs:
  gitops_repo:
    description: 'Repo GitOps destino en formato owner/repo o URL (ej: Automya/gitops).'
    required: true
  staging_manifest_path:
    description: 'Ruta del manifiesto Kubernetes para staging dentro del repo GitOps.'
    required: true
  prod_manifest_path:
    description: 'Ruta del manifiesto Kubernetes para producción dentro del repo GitOps.'
    required: true
  image_name:
    description: 'Nombre del contenedor (.spec.template.spec.containers[].name) a modificar.'
    required: true
  github_token:
    description: 'Token con permisos write en el repo GitOps (PAT o GITHUB_TOKEN elevado).'
    required: true
  source_repo_token:
    description: 'Token para comentar en la PR origen (opcional, default usa github_token).'
    required: false
    default: ''
  base_branch:
    description: 'Rama base en el repo GitOps (main por defecto).'
    required: false
    default: 'main'
  pr_title:
    description: 'Título base de la PR que se creará en el repo GitOps.'
    required: false
    default: 'chore: update image tag'
runs:
  using: composite
  steps:
    - name: Initialize action context
      shell: bash
      run: |
        set -euo pipefail
        : > "$GITHUB_WORKSPACE/action_error.txt"
        if [ -n "${{ inputs.source_repo_token }}" ]; then
          echo "COMMENT_TOKEN=${{ inputs.source_repo_token }}" >> $GITHUB_ENV
        else
          echo "COMMENT_TOKEN=${{ inputs.github_token }}" >> $GITHUB_ENV
        fi
        echo "SKIP=false" >> $GITHUB_ENV

    - name: Parse deploy command from PR comment
      shell: bash
      run: |
        set -euo pipefail
        BODY="${{ github.event.comment.body || '' }}"
        if [ -z "$BODY" ]; then
          echo "No hay comentario disponible. Esta acción solo responde a issue_comment."
          echo "SKIP=true" >> $GITHUB_ENV
          exit 0
        fi

        export BODY
        PARSED_ENV="$RUNNER_TEMP/deploy_env.txt"
        set +e
        python3 <<'PY' > "$PARSED_ENV"
import os, re, sys
body = os.environ.get("BODY", "")
if not re.search(r'\bdeploy\b', body, re.I):
    sys.exit(2)
tag_match = re.search(r'-t\s+([A-Za-z0-9._-]+)', body)
env_match = re.search(r'-e\s+(staging|stage|st|prod|production|prd)', body, re.I)
if not tag_match or not env_match:
    sys.exit(1)
tag = tag_match.group(1)
raw_env = env_match.group(1).lower()
target = 'prod' if raw_env in ('prod', 'production', 'prd') else 'staging'
print(f"DEPLOY_TAG={tag}")
print(f"TARGET_ENV={target}")
PY
        status=$?
        set -e

        if [ "$status" -eq 2 ]; then
          echo "Comentario sin comando deploy. Nada que hacer."
          echo "SKIP=true" >> $GITHUB_ENV
          exit 0
        elif [ "$status" -ne 0 ]; then
          echo "El comentario debe incluir 'deploy -t <tag> -e <staging|prod>'."
          exit 1
        fi

        cat "$PARSED_ENV" >> $GITHUB_ENV
        echo "Comando detectado:"
        cat "$PARSED_ENV"

    - name: Normalize GitOps repository reference
      if: ${{ env.SKIP == 'false' }}
      shell: bash
      run: |
        set -euo pipefail
        RAW="${{ inputs.gitops_repo }}"
        if [ -z "$RAW" ]; then
          echo "gitops_repo no puede ser vacío"
          exit 1
        fi
        repo="$RAW"
        repo="${repo#https://github.com/}"
        repo="${repo#http://github.com/}"
        repo="${repo#github.com/}"
        repo="${repo#git@github.com:}"
        repo="${repo#git@www.github.com:}"
        repo="${repo#www.github.com/}"
        repo="${repo#/}"
        repo="${repo%.git}"
        if ! echo "$repo" | grep -q '/'; then
          echo "No se pudo normalizar el repo GitOps (esperado owner/repo): $RAW"
          exit 1
        fi
        echo "GITOPS_REPO=$repo" >> $GITHUB_ENV
        echo "Repositorio GitOps normalizado: $repo"

    - name: Checkout GitOps repository
      if: ${{ env.SKIP == 'false' }}
      uses: actions/checkout@v4
      with:
        repository: ${{ env.GITOPS_REPO }}
        token: ${{ inputs.github_token }}
        path: gitops-repo

    - name: Ensure yq is available
      if: ${{ env.SKIP == 'false' }}
      shell: bash
      run: |
        set -euo pipefail
        if ! command -v yq >/dev/null 2>&1; then
          curl -sSL https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64 -o /usr/local/bin/yq
          chmod +x /usr/local/bin/yq
        fi
        yq --version

    - name: Select manifest path
      if: ${{ env.SKIP == 'false' }}
      shell: bash
      run: |
        set -euo pipefail
        if [ "${{ env.TARGET_ENV }}" = "prod" ]; then
          manifest="${{ inputs.prod_manifest_path }}"
        else
          manifest="${{ inputs.staging_manifest_path }}"
        fi
        echo "MANIFEST_PATH=${manifest}" >> $GITHUB_ENV
        echo "Se usará el manifiesto: ${manifest}"

    - name: Update manifest with new tag
      if: ${{ env.SKIP == 'false' }}
      shell: bash
      working-directory: gitops-repo
      env:
        TAG: ${{ env.DEPLOY_TAG }}
        CONTAINER_NAME: ${{ inputs.image_name }}
        FILE: ${{ env.MANIFEST_PATH }}
      run: |
        set -euo pipefail
        ERRFILE="$GITHUB_WORKSPACE/action_error.txt"
        trap 'rc=$?; echo "ERROR actualizando manifiesto (exit $rc)" >> "$ERRFILE"; exit $rc' ERR

        if [ ! -f "$FILE" ]; then
          echo "No existe el manifiesto $FILE" | tee -a "$ERRFILE"
          exit 1
        fi

        current_image=$(yq eval -r ".spec.template.spec.containers[] | select(.name == env(CONTAINER_NAME)).image" "$FILE" | head -n 1)
        if [ -z "$current_image" ] || [ "$current_image" = "null" ]; then
          echo "No se encontró el contenedor '${CONTAINER_NAME}' en $FILE" | tee -a "$ERRFILE"
          exit 1
        fi

        base="$current_image"
        if [[ "$base" == *@* ]]; then
          base="${base%%@*}"
        elif [[ "$base" == *:* ]]; then
          base="${base%:*}"
        fi
        if [ -z "$base" ]; then
          base="$current_image"
        fi

        NEW_IMAGE="${base}:${TAG}"
        export NEW_IMAGE

        yq eval -i '
          .spec.template.spec.containers |=
          (map(if .name == env(CONTAINER_NAME) then .image = env(NEW_IMAGE) else . end))
        ' "$FILE"

        if git diff --quiet -- "$FILE"; then
          echo "El manifiesto ya estaba en ${NEW_IMAGE}. Nada que hacer."
          echo "GITOPS_PR_URL=" >> $GITHUB_ENV
          exit 0
        fi

        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"
        git add "$FILE"
        git commit -m "chore: update ${CONTAINER_NAME} image to ${TAG}"

    - name: Push branch and create PR in GitOps repo
      if: ${{ env.SKIP == 'false' }}
      shell: bash
      working-directory: gitops-repo
      env:
        TAG: ${{ env.DEPLOY_TAG }}
        TARGET_ENV: ${{ env.TARGET_ENV }}
      run: |
        set -euo pipefail
        ERRFILE="$GITHUB_WORKSPACE/action_error.txt"
        trap 'rc=$?; echo "ERROR creando PR/push (exit $rc)" >> "$ERRFILE"; exit $rc' ERR

        owner_repo="${{ env.GITOPS_REPO }}"
        TOKEN="${{ inputs.github_token }}"
        BASE="${{ inputs.base_branch }}"
        IMAGE="${{ inputs.image_name }}"

        BRANCH="deploy/${TARGET_ENV}/${IMAGE}-${TAG}"
        PR_TITLE="${{ inputs.pr_title }} (${TARGET_ENV})"
        COMMENT_NUMBER="${{ github.event.issue.number || github.event.pull_request.number || github.event.number || '' }}"
        PR_BODY=$(cat <<'EOF'
Actualización automática solicitada desde comentario:

```
${{ github.event.comment.body || '' }}
```

- Contenedor: $IMAGE
- Tag nuevo: $TAG
- Entorno: $TARGET_ENV
EOF
)

        git fetch origin "$BASE" --depth=50 || true
        git checkout -B "$BRANCH"
        git push --force-with-lease "https://x-access-token:${TOKEN}@github.com/${owner_repo}.git" "$BRANCH"

        api_url="https://api.github.com/repos/${owner_repo}/pulls"
        payload=$(printf '{"title":"%s","head":"%s","base":"%s","body":%s}' \
          "$PR_TITLE" "$BRANCH" "$BASE" "$(printf '%s' "$PR_BODY" | python3 -c 'import json,sys; print(json.dumps(sys.stdin.read()))')")

        pr_response=$(curl -sS -X POST -H "Authorization: token ${TOKEN}" \
          -H "Accept: application/vnd.github+json" "$api_url" -d "$payload")
        pr_url=$(printf '%s' "$pr_response" | python3 -c 'import json,sys; j=json.load(sys.stdin); print(j.get("html_url",""))')
        pr_number=$(printf '%s' "$pr_response" | python3 -c 'import json,sys; j=json.load(sys.stdin); print(j.get("number",""))')

        if [ -z "$pr_url" ]; then
          echo "La creación de la PR falló: $pr_response" | tee -a "$ERRFILE"
          exit 1
        fi

        echo "GITOPS_PR_URL=$pr_url" >> $GITHUB_ENV
        echo "GITOPS_PR_NUMBER=$pr_number" >> $GITHUB_ENV

    - name: Report result back to source PR
      if: always()
      uses: actions/github-script@v7
      env:
        COMMENT_TOKEN: ${{ env.COMMENT_TOKEN }}
        ERRFILE: ${{ github.workspace }}/action_error.txt
        GITOPS_PR_URL: ${{ env.GITOPS_PR_URL }}
      with:
        github-token: ${{ env.COMMENT_TOKEN }}
        script: |
          const fs = require('fs');
          const errFile = process.env.ERRFILE;
          const hasError = fs.existsSync(errFile) && fs.readFileSync(errFile, 'utf8').trim().length > 0;
          const prUrl = process.env.GITOPS_PR_URL || '';
          let body = '';
          if (hasError) {
            body = ':x: No se pudo actualizar el manifiesto.\n\n```\n' +
              fs.readFileSync(errFile, 'utf8') + '\n```\n';
            if (prUrl) body += `Se alcanzó a crear la PR en GitOps: ${prUrl}\n`;
          } else if (prUrl) {
            body = ':white_check_mark: Imagen actualizada en GitOps.\n' +
              `PR creada: ${prUrl}\n`;
          } else {
            body = ':white_check_mark: El manifiesto ya estaba actualizado; no se creó PR.\n';
          }
          body += '\nComentario original:\n> ' +
            (context.payload.comment && context.payload.comment.body
              ? context.payload.comment.body
              : '(sin contenido)');

          const issueNumber = context.issue?.number ||
            context.payload?.issue?.number ||
            context.payload?.pull_request?.number;
          if (!issueNumber) {
            core.info('No se encontró número de PR/issue para comentar.');
            return;
          }

          await github.rest.issues.createComment({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: issueNumber,
            body
          });

