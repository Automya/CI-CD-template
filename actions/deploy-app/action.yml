name: Update GitOps Image Tag
description: Modifica el tag de la imagen de un contenedor (buscando por container.name) en un manifiesto Kubernetes, hace commit y crea/mergea una PR en el repo GitOps. Reporta resultado en la PR de origen.
inputs:
  gitops_repo:
    description: 'Repo destino en formato owner/repo o URL (ej: myorg/gitops o github.com/myorg/gitops.git).'
    required: true
  staging_manifest_path:
    description: 'Ruta al manifiesto para staging dentro del repo (ej. automya-vending/overlays/staging/.../patch-image.yaml).'
    required: true
  prod_manifest_path:
    description: 'Ruta al manifiesto para prod dentro del repo.'
    required: true
  image_name:
    description: 'Nombre del contenedor (campo .name) a buscar en spec.template.spec.containers (ej. automya-vending-operation).'
    required: true
  github_token:
    description: 'Token con permisos write en el repo destino GitOps (PAT con repo write). Debe pasarse desde el workflow consumidor.'
    required: true
  source_repo_token:
    description: 'Token para interactuar con la PR de origen (comentarios). Debe pasarse desde el workflow consumidor.'
    required: false
    default: ''
  base_branch:
    description: 'Base branch para la PR/merge (por defecto main).'
    required: false
    default: 'main'
  pr_title:
    description: 'Título de la PR.'
    required: false
    default: 'chore: update image tag'
  tag:
    description: 'Tag de imagen explícito. Si se define, tiene prioridad sobre lo indicado en comentarios.'
    required: false
    default: ''
  target_env:
    description: "Forzar entorno objetivo (staging/prod). Si no se establece se infiere del comentario."
    required: false
    default: ''
runs:
  using: composite
  steps:
    - name: "Init: set comment token and create error file"
      shell: bash
      run: |
        if [ -n "${{ inputs.source_repo_token }}" ]; then
          echo "COMMENT_TOKEN=${{ inputs.source_repo_token }}" >> $GITHUB_ENV
          echo "COMMENT_TOKEN_PROVIDED=true" >> $GITHUB_ENV
        else
          echo "COMMENT_TOKEN=${{ inputs.github_token }}" >> $GITHUB_ENV
          echo "COMMENT_TOKEN_PROVIDED=false" >> $GITHUB_ENV
        fi
        : > "$GITHUB_WORKSPACE/action_error.txt"
        echo "Initialized COMMENT_TOKEN and cleared action_error.txt"

    - name: "Resolve tag and target environment"
      shell: bash
      run: |
        set -euo pipefail
        BODY="${{ github.event.comment.body || '' }}"
        TAG_INPUT="${{ inputs.tag }}"
        ENV_INPUT="${{ inputs.target_env }}"
        TAG="$TAG_INPUT"
        if [ -z "$TAG" ]; then
          TAG=$(echo "$BODY" | grep -oP '(?i)tag:\s*\K[^\s]+' | head -n1 || true)
        fi
        ENV=""
        if [ -n "$ENV_INPUT" ]; then
          ENV="$ENV_INPUT"
        else
          ENV=$(echo "$BODY" | grep -oP '(?i)env:\s*\K(staging|stage|st|prod|production|prd)\b' | head -n1 || true)
          if [ -z "$ENV" ]; then
            ENV=$(echo "$BODY" | grep -oP '(?i)\b(staging|stage|st|prod|production|prd)\b' | head -n1 || true)
          fi
        fi
        if [ -n "$ENV" ]; then
          env_lc=$(echo "$ENV" | tr '[:upper:]' '[:lower:]')
          case "$env_lc" in
            prod|production|prd) TARGET_ENV="prod" ;;
            staging|stage|st) TARGET_ENV="staging" ;;
            *) TARGET_ENV="staging" ;;
          esac
        else
          TARGET_ENV="staging"
        fi
        if [ -z "$TAG" ]; then
          echo "No tag provided via input or comment. Skipping."
          echo "SKIP=true" >> $GITHUB_ENV
          exit 0
        fi
        echo "TAG=$TAG" >> $GITHUB_ENV
        echo "TARGET_ENV=$TARGET_ENV" >> $GITHUB_ENV
        echo "SKIP=false" >> $GITHUB_ENV
        echo "Found TAG=$TAG for env=$TARGET_ENV"

    - name: "Normalize GitOps repository reference"
      if: ${{ env.SKIP == 'false' }}
      shell: bash
      run: |
        set -euo pipefail
        RAW_REPO="${{ inputs.gitops_repo }}"
        if [ -z "$RAW_REPO" ]; then
          echo "gitops_repo no puede estar vacío"
          exit 1
        fi
        cleaned="$RAW_REPO"
        cleaned="${cleaned#https://github.com/}"
        cleaned="${cleaned#http://github.com/}"
        cleaned="${cleaned#github.com/}"
        cleaned="${cleaned#git@github.com:}"
        cleaned="${cleaned#git@www.github.com:}"
        cleaned="${cleaned#www.github.com/}"
        cleaned="${cleaned#/}"
        cleaned="${cleaned%.git}"
        if ! echo "$cleaned" | grep -q '/'; then
          echo "No se pudo normalizar el repo GitOps (se esperaba owner/repo), valor actual: $cleaned"
          exit 1
        fi
        echo "GITOPS_REPO_OWNER_AND_NAME=$cleaned" >> $GITHUB_ENV
        echo "Normalizado gitops_repo a $cleaned"

    - name: "Checkout GitOps repository"
      if: ${{ env.SKIP == 'false' }}
      uses: actions/checkout@v4
      with:
        repository: ${{ env.GITOPS_REPO_OWNER_AND_NAME }}
        token: ${{ inputs.github_token }}
        path: gitops-repo

    - name: "Install mikefarah yq (v4)"
      if: ${{ env.SKIP == 'false' }}
      shell: bash
      run: |
        set -euo pipefail
        if command -v yq >/dev/null 2>&1; then
          ver=$(yq --version 2>/dev/null || true)
          if echo "$ver" | grep -qi 'mikefarah'; then
            echo "Found mikefarah yq: $ver"
          else
            curl -sL https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64 -o /usr/local/bin/yq
            chmod +x /usr/local/bin/yq
          fi
        else
          curl -sL https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64 -o /usr/local/bin/yq
          chmod +x /usr/local/bin/yq
        fi
        yq --version

    - name: "Determine manifest path"
      if: ${{ env.SKIP == 'false' }}
      shell: bash
      run: |
        if [ "${{ env.TARGET_ENV }}" = "prod" ]; then
          manifest="${{ inputs.prod_manifest_path }}"
        else
          manifest="${{ inputs.staging_manifest_path }}"
        fi
        echo "MANIFEST_PATH=${manifest}" >> $GITHUB_ENV
        echo "Using MANIFEST_PATH=${manifest}"

    - name: "Update container image by container.name (yq) and commit if changed"
      if: ${{ env.SKIP == 'false' }}
      shell: bash
      working-directory: gitops-repo
      env:
        TAG: ${{ env.TAG }}
        CONTAINER_NAME: ${{ inputs.image_name }}
        FILE: ${{ env.MANIFEST_PATH }}
      run: |
        set -euo pipefail
        ERRFILE="$GITHUB_WORKSPACE/action_error.txt"
        trap 'rc=$?; echo "ERROR updating manifest, exit_code=$rc" >> "$ERRFILE"; exit $rc' ERR

        echo "DEBUG: file = $FILE"
        if [ ! -f "$FILE" ]; then
          echo "Manifest $FILE not found" >> "$ERRFILE"
          echo "Manifest $FILE not found"
          exit 1
        fi

        echo "----- file before -----"
        sed -n '1,200p' "$FILE" || true
        echo "-----------------------"

        changed=0
        cnt=$(yq eval '.spec.template.spec.containers | length' "$FILE" 2>/dev/null || echo 0)
        if [ "$cnt" = "null" ]; then cnt=0; fi
        echo "DEBUG: containers count = $cnt"

        if [ "$cnt" -gt 0 ]; then
          i=0
          while [ "$i" -lt "$cnt" ]; do
            cname=$(yq eval -r ".spec.template.spec.containers[$i].name // \"\"" "$FILE")
            img=$(yq eval -r ".spec.template.spec.containers[$i].image // \"\"" "$FILE")
            if [ -z "$cname" ] || [ -z "$img" ]; then
              i=$((i+1))
              continue
            fi
            if [ "$cname" = "$CONTAINER_NAME" ]; then
              if echo "$img" | grep -q "@"; then
                base="${img%%@*}"
              else
                base="${img%:*}"
              fi
              if [ -z "$base" ]; then
                if echo "$img" | grep -q "@"; then base="${img%%@*}"; else base="${img%:*}"; fi
              fi
              new_image="${base}:${TAG}"
              yq eval -i ".spec.template.spec.containers[$i].image = \"${new_image}\"" "$FILE"
              echo "Updated container name='$cname' image -> $new_image"
              changed=1
              # break   # uncomment if only the first match should be updated
            fi
            i=$((i+1))
          done
        fi

        if [ "$changed" -eq 0 ]; then
          echo "DEBUG: No container updated via yq. Trying Python fallback for ${CONTAINER_NAME}..."
          # Python fallback: safer regex replacements (digest -> tag, tag -> tag)
          python3 - <<'PY'
import os, re, sys
fpath = os.environ.get('FILE')
tag = os.environ.get('TAG','')
name = os.environ.get('CONTAINER_NAME','')
if not fpath or not tag or not name:
    print("PY fallback missing env vars", fpath, tag, name)
    sys.exit(0)
s = open(fpath,'r',encoding='utf-8').read()
# replace digest occurrences: .../NAME@sha256:...
s2 = re.sub(r'((?:[^\s"\'/]*/)?'+re.escape(name)+r')@sha256:[a-fA-F0-9]{64}', r'\1:'+tag, s)
# replace explicit tags: .../NAME:OLDTAG
s2 = re.sub(r'((?:[^\s"\'/]*/)?'+re.escape(name)+r'):[A-Za-z0-9._-]+', r'\1:'+tag, s2)
if s2 != s:
    open(fpath,'w',encoding='utf-8').write(s2)
    print("Python fallback updated file")
else:
    print("Python fallback made no changes")
PY

          if git diff --no-ext-diff --quiet --exit-code -- "$FILE"; then
            echo "Textual fallback made no changes."
          else
            echo "Textual fallback updated $FILE"
            changed=1
          fi
        fi

        echo "----- file after -----"
        sed -n '1,200p' "$FILE" || true
        echo "----------------------"

        if [ "$changed" -eq 0 ]; then
          echo "No changes detected after attempts. Exiting."
          echo "GITOPS_PR_URL=" >> $GITHUB_ENV
          exit 0
        fi

        git add -- "$FILE"
        if git diff --cached --quiet; then
          echo "No staged changes after add; exiting."
          exit 0
        fi
        git commit -m "chore: update ${CONTAINER_NAME} image to ${TAG}" || true
        echo "Committed changes locally:"
        git --no-pager log -1 --pretty=oneline

    - name: "Create branch, push and create+merge PR (GitOps repo) with verification"
      if: ${{ env.SKIP == 'false' }}
      shell: bash
      working-directory: gitops-repo
      run: |
        set -euo pipefail
        ERRFILE="$GITHUB_WORKSPACE/action_error.txt"
        trap 'rc=$?; echo "ERROR creating PR/pushing, exit_code=$rc" >> "$ERRFILE"; exit $rc' ERR

        owner_repo="${{ env.GITOPS_REPO_OWNER_AND_NAME }}"

        TOKEN="${{ inputs.github_token }}"
        BRANCH="update-image/${{ inputs.image_name }}-${{ env.TAG }}"
        PR_TITLE="${{ inputs.pr_title }} - ${{ inputs.image_name }} -> ${TAG}"
        PR_BODY="Automated PR to update image '${{ inputs.image_name }}' to tag '${TAG}'. Source: comment on PR #${{ github.event.issue.number || github.event.pull_request.number || '' }}."
        BASE="${{ inputs.base_branch }}"

        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"

        git remote set-url origin "https://x-access-token:${TOKEN}@github.com/${owner_repo}.git"
        git fetch --no-tags --prune --depth=50 origin "$BASE" || git fetch origin "$BASE" || true

        origin_base_sha=$(git rev-parse origin/"$BASE" 2>/dev/null || echo "")
        head_sha=$(git rev-parse HEAD 2>/dev/null || echo "")
        echo "DEBUG: origin/$BASE sha = $origin_base_sha"
        echo "DEBUG: HEAD sha = $head_sha"

        commits_ahead=$(git rev-list --count origin/"$BASE"..HEAD 2>/dev/null || echo 0)
        if [ -z "$commits_ahead" ]; then commits_ahead=0; fi
        echo "Commits ahead of origin/$BASE: $commits_ahead"

        if [ "$commits_ahead" -eq 0 ] && [ -n "$origin_base_sha" ] && [ -n "$head_sha" ] && [ "$origin_base_sha" != "$head_sha" ]; then
          echo "WARNING: rev-list returned 0 but HEAD != origin/$BASE. Treating as commits ahead."
          commits_ahead=1
        fi

        if [ "$commits_ahead" -eq 0 ]; then
          last_msg="$(git log -1 --pretty=%B 2>/dev/null || echo '')"
          if echo "$last_msg" | grep -q "chore: update ${IMAGE_NAME} image to ${TAG}"; then
            echo "Found matching local commit message; treating as commits ahead."
            commits_ahead=1
          fi
        fi

        owner=$(echo "$owner_repo" | cut -d'/' -f1)
        repo=$(echo "$owner_repo" | cut -d'/' -f2)

        if [ "$commits_ahead" -eq 0 ]; then
          echo "No commits ahead of $BASE. Searching for existing open PR for $BRANCH..."
          prs_api="https://api.github.com/repos/${owner_repo}/pulls?state=open&head=${owner}:${BRANCH}"
          prs_resp=$(curl -s -H "Authorization: token ${TOKEN}" -H "Accept: application/vnd.github+json" "$prs_api")
          pr_html=$(echo "$prs_resp" | python3 -c 'import sys,json; j=json.load(sys.stdin); print(j[0].get("html_url","") if isinstance(j,list) and len(j)>0 else "")' 2>/dev/null || echo "")
          pr_number=$(echo "$prs_resp" | python3 -c 'import sys,json; j=json.load(sys.stdin); print(j[0].get("number","") if isinstance(j,list) and len(j)>0 else "")' 2>/dev/null || echo "")
          if [ -n "$pr_html" ]; then
            echo "Found existing PR: $pr_html"
            echo "GITOPS_PR_URL=$pr_html" >> $GITHUB_ENV
            echo "GITOPS_PR_NUMBER=$pr_number" >> $GITHUB_ENV
            exit 0
          fi
          echo "No existing PR and no commits ahead. Nothing to do."
          exit 0
        fi

        git checkout -B "$BRANCH"
        git push --force-with-lease origin "$BRANCH"

        remote_sha=$(git ls-remote origin "refs/heads/${BRANCH}" | awk '{print $1}' || echo "")
        head_sha_now=$(git rev-parse HEAD || echo "")
        echo "DEBUG: remote branch sha = $remote_sha"
        echo "DEBUG: head sha now    = $head_sha_now"
        if [ -z "$remote_sha" ] || [ "$remote_sha" != "$head_sha_now" ]; then
          echo "Push verification failed: remote branch sha does not match HEAD. Remote response:" >> "$ERRFILE"
          git ls-remote origin "refs/heads/${BRANCH}" >> "$ERRFILE" || true
          echo "Aborting due to push failure." >> "$ERRFILE"
          exit 1
        fi

        api_url="https://api.github.com/repos/${owner_repo}/pulls"
        pr_payload=$(printf '{"title":"%s","head":"%s","base":"%s","body":"%s"}' "$PR_TITLE" "$BRANCH" "$BASE" "$PR_BODY")
        pr_response=$(curl -s -X POST -H "Authorization: token ${TOKEN}" -H "Accept: application/vnd.github+json" "$api_url" -d "$pr_payload")
        pr_html=$(echo "$pr_response" | python3 -c 'import sys,json; j=json.load(sys.stdin); print(j.get("html_url",""))' 2>/dev/null || echo "")
        pr_number=$(echo "$pr_response" | python3 -c 'import sys,json; j=json.load(sys.stdin); print(j.get("number",""))' 2>/dev/null || echo "")

        if [ -z "$pr_html" ]; then
          echo "Failed to create PR. Response: $pr_response" >> "$ERRFILE"
          exit 1
        fi
        echo "Created PR: $pr_html (number: $pr_number)"
        echo "GITOPS_PR_URL=$pr_html" >> $GITHUB_ENV
        echo "GITOPS_PR_NUMBER=$pr_number" >> $GITHUB_ENV

        merge_url="https://api.github.com/repos/${owner_repo}/pulls/${pr_number}/merge"
        merge_payload='{"commit_title":"'"${PR_TITLE}"'","merge_method":"merge"}'
        merge_response=$(curl -s -X PUT -H "Authorization: token ${TOKEN}" -H "Accept: application/vnd.github+json" "$merge_url" -d "$merge_payload")
        merged=$(echo "$merge_response" | python3 -c 'import sys,json; j=json.load(sys.stdin); print(str(j.get("merged", False)))' 2>/dev/null || echo "false")
        if [ "$merged" = "True" ] || [ "$merged" = "true" ]; then
          echo "PR merged successfully."
        else
          echo "Auto-merge failed or not permitted. Merge response: $merge_response" >> "$ERRFILE"
          echo "Auto-merge response recorded in $ERRFILE"
        fi

    - name: "Report result to source PR (always)"
      if: always()
      uses: actions/github-script@v6
      env:
        COMMENT_TOKEN: ${{ env.COMMENT_TOKEN }}
        ERRFILE: ${{ github.workspace }}/action_error.txt
        GITOPS_PR_URL: ${{ env.GITOPS_PR_URL }}
      with:
        github-token: ${{ env.COMMENT_TOKEN }}
        script: |
          const fs = require('fs');
          const errFile = process.env.ERRFILE;
          const hasError = fs.existsSync(errFile) && fs.readFileSync(errFile,'utf8').trim().length > 0;
          const prUrl = process.env.GITOPS_PR_URL || '';
          let body = '';
          if (hasError) {
            body = ':x: Update image tag action failed or had warnings.\n\n**Details:**\n```\n' + fs.readFileSync(errFile,'utf8') + '\n```\n';
            if (prUrl) body += `\nPR creada en repo GitOps: ${prUrl}\n`;
          } else {
            body = ':white_check_mark: Update image tag action completed successfully.\n\n';
            if (prUrl) body += `Se ha creado/actualizado la PR en el repo GitOps: ${prUrl}\n`;
            else body += 'No se creó PR porque no había cambios.\n';
          }
          body += `\nRequested by comment:\n> ${context.payload.comment && context.payload.comment.body ? context.payload.comment.body : '(contenido no disponible)'}\n`;
          const issueNumber = context.issue?.number || (context.payload && context.payload.issue && context.payload.issue.number) || (context.payload && context.payload.pull_request && context.payload.pull_request.number);
          if (!issueNumber) {
            console.log('No issue/pr number in context; cannot post a comment.');
            return;
          }
          await github.rest.issues.createComment({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: issueNumber,
            body
          });