name: Deploy GitOps Image
description: >
  Actualiza el tag de una imagen en el repo de GitOps (staging o prod) leyendo el
  comando `deploy -t <tag> -e <env>` desde un comentario de PR y sube los cambios
  al repositorio GitOps mediante una PR automÃ¡tica.
inputs:
  gitops_repo:
    description: "Repo GitOps destino en formato owner/repo o URL (ej: Automya/gitops)."
    required: true
  staging_manifest_path:
    description: "Ruta del manifiesto Kubernetes para staging dentro del repo GitOps."
    required: true
  prod_manifest_path:
    description: "Ruta del manifiesto Kubernetes para producciÃ³n dentro del repo GitOps."
    required: true
  image_name:
    description: "Nombre del contenedor (.spec.template.spec.containers[].name) a modificar."
    required: true
  github_token:
    description: "Token con permisos write en el repo GitOps (PAT o GITHUB_TOKEN elevado)."
    required: true
  source_repo_token:
    description: "Token para comentar en la PR origen (opcional, default usa github_token)."
    required: false
    default: ""
  base_branch:
    description: "Rama base en el repo GitOps (main por defecto)."
    required: false
    default: "main"
  pr_title:
    description: "TÃ­tulo base de la PR que se crearÃ¡ en el repo GitOps."
    required: false
    default: "chore: update image tag"
  staging_cluster_name:
    description: "Staging GKE Cluster Name"
    required: true
  prod_cluster_name:
    description: "Prod GKE Cluster Name"
    required: true
  staging_cluster_location:
    description: "Staging GKE Cluster Location"
    required: true
  prod_cluster_location:
    description: "Prod GKE Cluster Location"
    required: true
  project_id:
    description: "GCP Project ID (shared for both clusters)"
    required: true
  deployment_name:
    description: "K8s Deployment name to restart (defaults to image_name if not set)"
    required: false
  namespace:
    description: "K8s Namespace (default: default)"
    required: false
    default: "default"
  google_chat_webhook:
    description: "Webhook URL para notificaciones a Google Chat (opcional)."
    required: false
runs:
  using: composite
  steps:
    - name: Initialize action context
      shell: bash
      run: |
        set -euo pipefail
        : > "$GITHUB_WORKSPACE/action_error.txt"
        if [ -n "${{ inputs.source_repo_token }}" ]; then
          echo "COMMENT_TOKEN=${{ inputs.source_repo_token }}" >> $GITHUB_ENV
        else
          echo "COMMENT_TOKEN=${{ inputs.github_token }}" >> $GITHUB_ENV
        fi
        echo "SKIP=false" >> $GITHUB_ENV

    - name: Parse deploy command from PR comment
      shell: bash
      run: |
        set -euo pipefail
        BODY="${{ github.event.comment.body || '' }}"

        echo "Comentario recibido:"
        echo "$BODY"

        # CorrecciÃ³n warning grep: Escapamos los dos puntos para que no parezca una clase POSIX
        if echo "$BODY" | grep -qE '^\:white_check_mark\:|^\:x\:|^Imagen actualizada|^No se pudo actualizar'; then
          echo "El comentario parece ser una respuesta automÃ¡tica de esta acciÃ³n. Se ignora."
          echo "SKIP=true" >> $GITHUB_ENV
          exit 0
        fi

        if [ -z "$BODY" ]; then
          echo "No hay comentario disponible."
          echo "SKIP=true" >> $GITHUB_ENV
          exit 0
        fi

        BODY_TRIMMED=$(echo "$BODY" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')

        # 1. DetecciÃ³n de intenciÃ³n: Â¿Empieza con deploy?
        if ! echo "$BODY_TRIMMED" | grep -qi '^deploy'; then
           echo "El comentario no comienza con 'deploy'. Se ignora."
           echo "SKIP=true" >> $GITHUB_ENV
           exit 0
        fi

        # 2. ValidaciÃ³n de formato estricto
        # Si llegamos aquÃ­, ES un deploy, asÃ­ que cualquier error debe reportarse.
        echo "SKIP=false" >> $GITHUB_ENV

        if ! echo "$BODY_TRIMMED" | grep -qiE '^deploy[[:space:]]+-t[[:space:]]+[^[:space:]]+[[:space:]]+-e[[:space:]]+[^[:space:]]+'; then
          echo "âŒ Formato incorrecto."
          echo "Error de sintaxis: El comando no cumple el formato requerido." > "$GITHUB_WORKSPACE/action_error.txt"
          echo "Uso correcto: \`deploy -t <tag> -e <staging|prod>\`" >> "$GITHUB_WORKSPACE/action_error.txt"
          echo "Recibido: \`$BODY_TRIMMED\`" >> "$GITHUB_WORKSPACE/action_error.txt"
          exit 1
        fi

        TAG=$(echo "$BODY_TRIMMED" | grep -oE '\-t[[:space:]]+([^[:space:]]+)' | sed -E 's/\-t[[:space:]]+//' | head -n1 || echo "")
        ENV_RAW=$(echo "$BODY_TRIMMED" | grep -oE '\-e[[:space:]]+([^[:space:]]+)' | sed -E 's/\-e[[:space:]]+//' | head -n1 || echo "")

        if [ -z "$TAG" ] || [ -z "$ENV_RAW" ]; then
          echo "Error interno extrayendo variables." > "$GITHUB_WORKSPACE/action_error.txt"
          exit 1
        fi

        ENV_LOWER=$(echo "$ENV_RAW" | tr '[:upper:]' '[:lower:]')
        case "$ENV_LOWER" in
          staging|stage|st|stag|stg)
            TARGET_ENV="staging"
            ;;
          prod|production|prd)
            echo "âŒ Despliegue a producciÃ³n bloqueado."
            echo "Error: Despliegue a producciÃ³n via comando no permitido. Solo se permite via Release." > "$GITHUB_WORKSPACE/action_error.txt"
            echo "STOP_EXECUTION=true" >> $GITHUB_ENV
            # No hacemos exit 1 para permitir que los pasos de reporte final se ejecuten y comenten el error.
            ;;
          *)
            echo "âŒ Entorno desconocido: $ENV_RAW"
            echo "Error: El entorno '$ENV_RAW' no es vÃ¡lido." > "$GITHUB_WORKSPACE/action_error.txt"
            echo "Entornos permitidos: staging (o alias: stg)." >> "$GITHUB_WORKSPACE/action_error.txt"
            exit 1
            ;;
        esac

        echo "DEPLOY_TAG=$TAG" >> $GITHUB_ENV
        echo "TARGET_ENV=$TARGET_ENV" >> $GITHUB_ENV

        echo "Comando detectado y validado:"
        echo "  Tag: $TAG"
        echo "  Entorno: $TARGET_ENV"

    - name: Notify Start Deployment
      if: ${{ env.SKIP == 'false' }}
      uses: actions/github-script@v7
      env:
        IMAGE_NAME: ${{ inputs.image_name }}
        TAG: ${{ env.DEPLOY_TAG }}
        TARGET_ENV: ${{ env.TARGET_ENV }}
        WEBHOOK_URL: ${{ inputs.google_chat_webhook }}
      with:
        github-token: ${{ env.COMMENT_TOKEN }}
        script: |
          const tag = process.env.TAG;
          const imageName = process.env.IMAGE_NAME;
          const targetEnv = process.env.TARGET_ENV;
          const webhookUrl = process.env.WEBHOOK_URL;
          const runId = context.runId;
          const repo = context.repo;
          const actionUrl = `${process.env.GITHUB_SERVER_URL}/${repo.owner}/${repo.repo}/actions/runs/${runId}`;

          const body = `ðŸš€ **Iniciando Despliegue**\n` +
                       `- **Imagen:** \`${imageName}\`\n` +
                       `- **Tag:** \`${tag}\`\n` +
                       `- **Entorno:** \`${targetEnv}\`\n` +
                       `- [Ver Logs del Action](${actionUrl})\n` +
                       `â³ Procesando...`;

          // 1. Comment on GitHub PR
          const issueNumber = context.issue?.number ||
            context.payload?.issue?.number ||
            context.payload?.pull_request?.number;
            
          if (issueNumber) {
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber,
              body
            });
          } else {
             console.log("No issue number found, skipping PR comment.");
          }

          // 2. Notify Google Chat (if webhook provided)
          if (webhookUrl) {
             const payload = JSON.stringify({ text: body });
             // We use exec to run curl since we are in a JS context but have access to shell commands via exec
             // But actions/github-script doesn't export exec by default easily for complex curls without @actions/exec
             // So we will use fetch if available (Node 18+) or https module.
             // Since this runs in modern runner, fetch is likely available.
             
             try {
                const response = await fetch(webhookUrl, {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: payload
                });
                if (!response.ok) {
                   console.error(`Failed to send to Google Chat: ${response.status} ${response.statusText}`);
                } else {
                   console.log("Notification sent to Google Chat.");
                }
             } catch (error) {
                // Fallback for older Node environments or network issues
                console.error("Error sending to Google Chat:", error);
             }
          }

    - name: Normalize GitOps repository reference
      if: ${{ env.SKIP == 'false' && env.STOP_EXECUTION != 'true' }}
      shell: bash
      run: |
        set -euo pipefail
        RAW="${{ inputs.gitops_repo }}"
        if [ -z "$RAW" ]; then
          echo "gitops_repo no puede ser vacÃ­o"
          exit 1
        fi
        repo="$RAW"
        repo="${repo#https://github.com/}"
        repo="${repo#http://github.com/}"
        repo="${repo#github.com/}"
        repo="${repo#git@github.com:}"
        repo="${repo#git@www.github.com:}"
        repo="${repo#www.github.com/}"
        repo="${repo#/}"
        repo="${repo%.git}"
        if ! echo "$repo" | grep -q '/'; then
          echo "No se pudo normalizar el repo GitOps (esperado owner/repo): $RAW"
          exit 1
        fi
        echo "GITOPS_REPO=$repo" >> $GITHUB_ENV
        echo "Repositorio GitOps normalizado: $repo"

    - name: Checkout GitOps repository
      if: ${{ env.SKIP == 'false' && env.STOP_EXECUTION != 'true' }}
      uses: actions/checkout@v4
      with:
        repository: ${{ env.GITOPS_REPO }}
        token: ${{ inputs.github_token }}
        path: gitops-repo

    - name: Ensure yq is available
      if: ${{ env.SKIP == 'false' && env.STOP_EXECUTION != 'true' }}
      shell: bash
      run: |
        set -euo pipefail
        if ! command -v yq >/dev/null 2>&1; then
          curl -sSL https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64 -o /usr/local/bin/yq
          chmod +x /usr/local/bin/yq
        fi
        yq --version

    - name: Select manifest path
      if: ${{ env.SKIP == 'false' && env.STOP_EXECUTION != 'true' }}
      shell: bash
      run: |
        set -euo pipefail
        if [ "${{ env.TARGET_ENV }}" = "prod" ]; then
          manifest="${{ inputs.prod_manifest_path }}"
        else
          manifest="${{ inputs.staging_manifest_path }}"
        fi
        echo "MANIFEST_PATH=${manifest}" >> $GITHUB_ENV
        echo "Se usarÃ¡ el manifiesto: ${manifest}"

    - name: Verify image existence in Artifact Registry
      if: ${{ env.SKIP == 'false' && env.STOP_EXECUTION != 'true' }}
      shell: bash
      working-directory: gitops-repo
      env:
        TAG: ${{ env.DEPLOY_TAG }}
        CONTAINER_NAME: ${{ inputs.image_name }}
        FILE: ${{ env.MANIFEST_PATH }}
      run: |
        set -euo pipefail
        ERRFILE="$GITHUB_WORKSPACE/action_error.txt"

        if [ ! -f "$FILE" ]; then
          echo "No se encuentra el archivo de manifiesto: $FILE" > "$ERRFILE"
          exit 1
        fi

        # Extraer imagen actual usando yq para obtener el repo base
        CURRENT_IMAGE=$(yq eval ".spec.template.spec.containers[] | select(.name == \"$CONTAINER_NAME\") | .image" "$FILE" | head -n 1)

        if [ -z "$CURRENT_IMAGE" ] || [ "$CURRENT_IMAGE" = "null" ]; then
           echo "No se encontrÃ³ el contenedor '$CONTAINER_NAME' en '$FILE' o no tiene imagen." | tee -a "$ERRFILE"
           exit 1
        fi

        # Obtener repo base (quitar tag :tag o digest @sha256:...)
        BASE_IMAGE=$(echo "$CURRENT_IMAGE" | sed -E 's/[:@].*$//')
        TARGET_IMAGE="${BASE_IMAGE}:${TAG}"

        echo "Imagen base detectada: $BASE_IMAGE"
        echo "Verificando existencia de: $TARGET_IMAGE"

        if ! gcloud container images describe "$TARGET_IMAGE" --format='value(image_summary.digest)' &>/dev/null; then
          echo "âŒ Error: La imagen no existe en el registro."
          echo "Error: La imagen '$TARGET_IMAGE' no se encontrÃ³ en Artifact Registry/GCR." > "$ERRFILE"
          echo "Verifica que el pipeline de Build haya finalizado correctamente y el tag '$TAG' sea vÃ¡lido." >> "$ERRFILE"
          exit 1
        fi

        echo "âœ… Imagen verificada exitosamente."

    - name: Update manifest with new tag
      if: ${{ env.SKIP == 'false' && env.STOP_EXECUTION != 'true' }}
      shell: bash
      working-directory: gitops-repo
      env:
        TAG: ${{ env.DEPLOY_TAG }}
        CONTAINER_NAME: ${{ inputs.image_name }}
        FILE: ${{ env.MANIFEST_PATH }}
      run: |
        set -euo pipefail
        ERRFILE="$GITHUB_WORKSPACE/action_error.txt"
        trap 'rc=$?; echo "ERROR actualizando manifiesto (exit $rc)" >> "$ERRFILE"; exit $rc' ERR

        if [ ! -f "$FILE" ]; then
          echo "No existe el manifiesto $FILE" | tee -a "$ERRFILE"
          exit 1
        fi

        container_count=$(yq eval '.spec.template.spec.containers | length' "$FILE" 2>/dev/null || echo "0")
        if [ "$container_count" = "null" ] || [ "$container_count" = "0" ]; then
          echo "No se encontraron contenedores en $FILE" | tee -a "$ERRFILE"
          exit 1
        fi

        found=0
        i=0
        while [ "$i" -lt "$container_count" ]; do
          container_name=$(yq eval -r ".spec.template.spec.containers[$i].name" "$FILE" 2>/dev/null || echo "")
          if [ "$container_name" = "$CONTAINER_NAME" ]; then
            current_image=$(yq eval -r ".spec.template.spec.containers[$i].image" "$FILE" 2>/dev/null || echo "")
            if [ -z "$current_image" ] || [ "$current_image" = "null" ]; then
              echo "El contenedor '${CONTAINER_NAME}' no tiene imagen definida en $FILE" | tee -a "$ERRFILE"
              exit 1
            fi

            base="$current_image"
            if [[ "$base" == *@* ]]; then
              base="${base%%@*}"
            elif [[ "$base" == *:* ]]; then
              base="${base%:*}"
            fi
            if [ -z "$base" ]; then
              base="$current_image"
            fi

            NEW_IMAGE="${base}:${TAG}"
            
            # Verificar si la imagen ya es la correcta ANTES de modificar
            if [ "$current_image" = "$NEW_IMAGE" ]; then
              echo "La imagen ya estÃ¡ en ${NEW_IMAGE}. Se requiere reinicio."
              echo "NEEDS_RESTART=true" >> $GITHUB_ENV
              echo "GITOPS_PR_URL=" >> $GITHUB_ENV
              exit 0
            fi
            
            yq eval -i ".spec.template.spec.containers[$i].image = \"${NEW_IMAGE}\"" "$FILE"
            echo "Actualizado contenedor '${CONTAINER_NAME}': ${current_image} -> ${NEW_IMAGE}"
            found=1
            break
          fi
          i=$((i + 1))
        done

        if [ "$found" -eq 0 ]; then
          echo "No se encontrÃ³ el contenedor '${CONTAINER_NAME}' en $FILE" | tee -a "$ERRFILE"
          exit 1
        fi

        # Si llegamos aquÃ­, hubo cambios (ya verificamos antes de modificar)
        echo "NEEDS_RESTART=false" >> $GITHUB_ENV

        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"
        git add "$FILE"
        git commit -m "chore: update ${CONTAINER_NAME} image to ${TAG}"

    - name: Push branch and create PR in GitOps repo
      if: ${{ env.SKIP == 'false' && env.NEEDS_RESTART != 'true' && env.STOP_EXECUTION != 'true' }}
      shell: bash
      working-directory: gitops-repo
      env:
        TAG: ${{ env.DEPLOY_TAG }}
        TARGET_ENV: ${{ env.TARGET_ENV }}
        GH_TOKEN: ${{ inputs.github_token }}
      run: |
        set -euo pipefail
        ERRFILE="$GITHUB_WORKSPACE/action_error.txt"
        trap 'rc=$?; echo "ERROR creando PR/push - exit code $rc" >> "$ERRFILE"; exit $rc' ERR

        owner_repo="${{ env.GITOPS_REPO }}"
        BASE="${{ inputs.base_branch }}"
        IMAGE="${{ inputs.image_name }}"

        BRANCH="deploy/${TARGET_ENV}/${IMAGE}-${TAG}"
        PR_TITLE="${{ inputs.pr_title }} (${TARGET_ENV})"

        PR_BODY=$(cat <<EOF
        ActualizaciÃ³n automÃ¡tica solicitada desde comentario:

        \`\`\`
        ${{ github.event.comment.body || '' }}
        \`\`\`

        - Contenedor: ${IMAGE}
        - Tag nuevo: ${TAG}
        - Entorno: ${TARGET_ENV}
        EOF
        )

        git fetch origin "$BASE" --depth=50 || true
        # Fetch the target branch if it exists to ensure we have the latest ref for force-with-lease
        git fetch origin "$BRANCH" --depth=1 || true
        git checkout -B "$BRANCH"
        git push --force-with-lease origin "$BRANCH"

        echo "Creando PR..."
        pr_url=$(gh pr create \
          --repo "$owner_repo" \
          --base "$BASE" \
          --head "$BRANCH" \
          --title "$PR_TITLE" \
          --body "$PR_BODY" 2>&1 | tee /dev/stderr | grep -oE 'https://github.com/[^[:space:]]+' || true)

        if [ -z "$pr_url" ]; then
          echo "La creaciÃ³n de la PR fallÃ³" | tee -a "$ERRFILE"
          exit 1
        fi

        echo "GITOPS_PR_URL=$pr_url" >> $GITHUB_ENV
        echo "PR creada: $pr_url"

        echo "Configurando auto-merge..."
        if gh pr merge "$pr_url" --auto --merge --delete-branch 2>&1; then
          echo "Auto-merge configurado. La PR se mergearÃ¡ automÃ¡ticamente cuando pasen los checks requeridos."
        else
          echo "Advertencia: No se pudo configurar auto-merge (puede que no estÃ© habilitado en el repo o que la PR ya estÃ© lista para merge)."
          echo "Intentando merge directo..."
          if gh pr merge "$pr_url" --merge --delete-branch 2>&1; then
            echo "PR mergeada exitosamente."
          else
            echo "No se pudo hacer merge automÃ¡tico ni directo. Revisa manualmente: $pr_url" | tee -a "$ERRFILE"
          fi
        fi

    - name: Get GKE credentials (Staging)
      if: ${{ env.SKIP == 'false' && env.NEEDS_RESTART == 'true' && env.TARGET_ENV == 'staging' && env.STOP_EXECUTION != 'true' }}
      uses: google-github-actions/get-gke-credentials@v1
      with:
        cluster_name: ${{ inputs.staging_cluster_name }}
        location: ${{ inputs.staging_cluster_location }}
        project_id: ${{ inputs.project_id }}

    - name: Get GKE credentials (Prod)
      if: ${{ env.SKIP == 'false' && env.NEEDS_RESTART == 'true' && env.TARGET_ENV == 'prod' && env.STOP_EXECUTION != 'true' }}
      uses: google-github-actions/get-gke-credentials@v1
      with:
        cluster_name: ${{ inputs.prod_cluster_name }}
        location: ${{ inputs.prod_cluster_location }}
        project_id: ${{ inputs.project_id }}

    - name: Restart Deployment
      if: ${{ env.SKIP == 'false' && env.NEEDS_RESTART == 'true' && env.STOP_EXECUTION != 'true' }}
      shell: bash
      env:
        DEPLOYMENT_NAME: ${{ inputs.deployment_name || inputs.image_name }}
        K8S_NAMESPACE: ${{ inputs.namespace }}
      run: |
        set -euo pipefail
        echo "Reiniciando deployment '$DEPLOYMENT_NAME' en namespace '$K8S_NAMESPACE'..."
        kubectl rollout restart deployment/"$DEPLOYMENT_NAME" -n "$K8S_NAMESPACE"
        kubectl rollout status deployment/"$DEPLOYMENT_NAME" -n "$K8S_NAMESPACE"
        echo "RESTART_SUCCESS=true" >> $GITHUB_ENV

    - name: Report result back to source PR
      id: report-pr
      if: always() && env.SKIP == 'false'
      uses: actions/github-script@v7
      env:
        JOB_STATUS: ${{ job.status }}
        COMMENT_TOKEN: ${{ env.COMMENT_TOKEN }}
        ERRFILE: ${{ github.workspace }}/action_error.txt
        GITOPS_PR_URL: ${{ env.GITOPS_PR_URL }}
        DEPLOY_TAG: ${{ env.DEPLOY_TAG }}
        TARGET_ENV: ${{ env.TARGET_ENV }}
        NEEDS_RESTART: ${{ env.NEEDS_RESTART }}
        RESTART_SUCCESS: ${{ env.RESTART_SUCCESS }}
      with:
        github-token: ${{ env.COMMENT_TOKEN }}
        script: |
          const fs = require('fs');
          const commentBody = context.payload.comment?.body || '';

          if (/^âœ…|^âŒ|^Imagen actualizada|^No se pudo actualizar/i.test(commentBody)) {
            core.info('El comentario parece ser una respuesta automÃ¡tica. No se publicarÃ¡ respuesta para evitar loops.');
            return;
          }

          const errFile = process.env.ERRFILE;
          const hasError = fs.existsSync(errFile) && fs.readFileSync(errFile, 'utf8').trim().length > 0;
          const prUrl = process.env.GITOPS_PR_URL || '';
          const deployTag = process.env.DEPLOY_TAG || '(tag no disponible)';
          const targetEnv = process.env.TARGET_ENV || '(entorno no disponible)';
          const jobStatus = process.env.JOB_STATUS;

          let body = '';
          if (hasError) {
            body = 'âŒ El despliegue del tag "' + deployTag + '" hacia "' + targetEnv + '" fallÃ³.\n\n```\n' +
              fs.readFileSync(errFile, 'utf8') + '\n```\n';
            if (prUrl) body += 'Se alcanzÃ³ a crear la PR en GitOps: ' + prUrl + '\n';
          } else if (jobStatus === 'failure' || jobStatus === 'cancelled') {
            body = 'âŒ **Error CrÃ­tico:** El workflow fallÃ³ inesperadamente antes de completar el despliegue.\n' +
                   'Revisa los logs de la acciÃ³n "Deploy GitOps Image" para mÃ¡s detalles.';
          } else if (prUrl) {
            body = 'âœ… Tag "' + deployTag + '" desplegado en "' + targetEnv + '".\n' +
              'PR en GitOps: ' + prUrl + '\n';
          } else if (process.env.NEEDS_RESTART === 'true') {
             if (process.env.RESTART_SUCCESS === 'true') {
                body = 'âœ… Tag "' + deployTag + '" ya existÃ­a en "' + targetEnv + '".\n' +
                       'Se ha reiniciado el deployment exitosamente para aplicar cambios.';
             } else {
                body = 'âŒ Tag "' + deployTag + '" ya existÃ­a, pero fallÃ³ el reinicio del deployment.\n' +
                       'Revisa los logs de la acciÃ³n para mÃ¡s detalles.';
             }
          } else {
            body = 'âœ…Tag "' + deployTag + '" ya estaba aplicado en "' + targetEnv + '"; no se creÃ³ PR ni se reiniciÃ³.\n';
          }

          core.setOutput('deploy_message', body);

          const issueNumber = context.issue?.number ||
            context.payload?.issue?.number ||
            context.payload?.pull_request?.number;
          if (!issueNumber) {
            core.info('No se encontrÃ³ nÃºmero de PR/issue para comentar.');
            return;
          }

          await github.rest.issues.createComment({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: issueNumber,
            body
          });

    - name: Notify Google Chat
      if: always() && env.SKIP == 'false' && inputs.google_chat_webhook != ''
      shell: bash
      env:
        WEBHOOK_URL: ${{ inputs.google_chat_webhook }}
        MESSAGE_BODY: ${{ steps.report-pr.outputs.deploy_message }}
      run: |
        set -euo pipefail

        if [ -z "$MESSAGE_BODY" ]; then
          echo "No message body available to send."
          exit 0
        fi

        # Use jq to construct JSON safely
        jq -n --arg text "$MESSAGE_BODY" '{text: $text}' > payload.json

        curl -s -H "Content-Type: application/json" \
          -d @payload.json \
          "$WEBHOOK_URL"
