name: "Sync Pages to Confluence"
description: "Core sync logic: converts Markdown to Confluence pages using md2cf"

inputs:
  confluence_url:
    description: "Confluence URL"
    required: true
  confluence_username:
    description: "Confluence username"
    required: true
  confluence_api_token:
    description: "Confluence API token"
    required: true
  space_key:
    description: "Confluence space key"
    required: true
  parent_page_id:
    description: "Parent page ID"
    required: true
  docs_folder:
    description: "Documentation folder path"
    required: true
  sync_mode:
    description: "Sync mode (all/changed)"
    required: false
    default: "changed"
  changed_files:
    description: "Space-separated list of changed files"
    required: false
    default: ""
  deleted_files:
    description: "Space-separated list of deleted files"
    required: false
    default: ""
  page_title_from_frontmatter:
    description: "Extract title from frontmatter"
    required: false
    default: "true"

outputs:
  synced_pages:
    description: "Number of synced pages"
    value: ${{ steps.sync.outputs.synced_pages }}
  failed_pages:
    description: "Number of failed pages"
    value: ${{ steps.sync.outputs.failed_pages }}
  confluence_urls:
    description: "JSON array of synced page URLs"
    value: ${{ steps.sync.outputs.confluence_urls }}

runs:
  using: "composite"
  steps:
    - name: Execute Sync
      id: sync
      shell: bash
      env:
        CONFLUENCE_URL: ${{ inputs.confluence_url }}
        CONFLUENCE_USERNAME: ${{ inputs.confluence_username }}
        CONFLUENCE_API_TOKEN: ${{ inputs.confluence_api_token }}
        SPACE_KEY: ${{ inputs.space_key }}
        PARENT_PAGE_ID: ${{ inputs.parent_page_id }}
        DOCS_FOLDER: ${{ inputs.docs_folder }}
        SYNC_MODE: ${{ inputs.sync_mode }}
        CHANGED_FILES: ${{ inputs.changed_files }}
        DELETED_FILES: ${{ inputs.deleted_files }}
        TITLE_FROM_FRONTMATTER: ${{ inputs.page_title_from_frontmatter }}
      run: |
        set -euo pipefail

        # Create inline Python script for Confluence sync
        python3 << 'PYTHON_SCRIPT_END'
        #!/usr/bin/env python3
        """
        Confluence Documentation Sync Script
        Syncs Markdown files to Confluence using md2cf library
        """
        import os
        import sys
        import json
        import yaml
        import requests
        from pathlib import Path
        from typing import Dict, List, Optional, Tuple
        from md2cf.confluence_renderer import ConfluenceRenderer
        import mistune

        # Configuration from environment
        CONFLUENCE_URL = os.environ['CONFLUENCE_URL'].rstrip('/')
        USERNAME = os.environ['CONFLUENCE_USERNAME']
        API_TOKEN = os.environ['CONFLUENCE_API_TOKEN']
        SPACE_KEY = os.environ['SPACE_KEY']
        PARENT_PAGE_ID = os.environ['PARENT_PAGE_ID']
        DOCS_FOLDER = os.environ['DOCS_FOLDER']
        SYNC_MODE = os.environ.get('SYNC_MODE', 'changed')
        CHANGED_FILES = os.environ.get('CHANGED_FILES', '').split()
        DELETED_FILES = os.environ.get('DELETED_FILES', '').split()
        TITLE_FROM_FRONTMATTER = os.environ.get('TITLE_FROM_FRONTMATTER', 'true').lower() == 'true'
        ERROR_FILE = os.environ.get('GITHUB_WORKSPACE', '.') + '/action_error.txt'
        GITHUB_OUTPUT = os.environ.get('GITHUB_OUTPUT', '')

        # State tracking
        synced_pages = []
        failed_pages = []

        class ConfluenceSync:
            def __init__(self):
                self.session = requests.Session()
                self.session.auth = (USERNAME, API_TOKEN)
                self.session.headers.update({
                    'Content-Type': 'application/json',
                    'Accept': 'application/json'
                })
                self.page_cache = {}  # title -> page_id mapping
                self.folder_cache = {}  # folder_path -> folder_id mapping
                self.space_id = None  # Will be fetched on first use

            def get_space_id(self, space_key: str) -> Optional[str]:
                """Get Space ID from Space Key using API v2"""
                if self.space_id:
                    return self.space_id

                try:
                    response = self.session.get(
                        f'{CONFLUENCE_URL}/api/v2/spaces',
                        params={'keys': space_key},
                        timeout=30
                    )

                    if response.status_code == 200:
                        results = response.json().get('results', [])
                        if results:
                            self.space_id = results[0]['id']
                            print(f"  Space ID for '{space_key}': {self.space_id}")
                            return self.space_id

                    print(f"  Error: Could not find space '{space_key}'")
                    return None
                except Exception as e:
                    print(f"  Error getting space ID: {e}")
                    return None

            def find_folder_by_title(self, title: str, parent_id: Optional[str] = None) -> Optional[str]:
                """Find folder ID by title using API v2"""
                try:
                    # Get space ID
                    space_id = self.get_space_id(SPACE_KEY)
                    if not space_id:
                        return None

                    # Search folders in space with pagination
                    params = {
                        'space-id': space_id,
                        'limit': 250  # Max results per page
                    }
                    if parent_id:
                        params['parent-id'] = parent_id

                    # Get all folders (handle pagination)
                    all_folders = []
                    next_cursor = None

                    while True:
                        if next_cursor:
                            params['cursor'] = next_cursor

                        response = self.session.get(
                            f'{CONFLUENCE_URL}/api/v2/folders',
                            params=params,
                            timeout=30
                        )

                        if response.status_code != 200:
                            break

                        data = response.json()
                        results = data.get('results', [])
                        all_folders.extend(results)

                        # Check if there are more pages
                        links = data.get('_links', {})
                        if 'next' not in links:
                            break

                        # Get next cursor from response
                        next_cursor = links.get('next', '').split('cursor=')[-1] if 'cursor=' in links.get('next', '') else None
                        if not next_cursor:
                            break

                    # Search for folder by title
                    for folder in all_folders:
                        if folder.get('title') == title:
                            folder_id = folder['id']
                            print(f"  Found existing folder: {title} (ID: {folder_id})")
                            return folder_id

                    return None
                except Exception as e:
                    print(f"  Warning: Error searching for folder '{title}': {e}")
                    return None

            def create_folder(self, title: str, parent_id: str) -> Optional[str]:
                """Create a new Confluence folder using API v2"""
                try:
                    space_id = self.get_space_id(SPACE_KEY)
                    if not space_id:
                        raise Exception("Could not get space ID")

                    payload = {
                        'spaceId': space_id,
                        'title': title,
                        'parentId': parent_id
                    }

                    response = self.session.post(
                        f'{CONFLUENCE_URL}/api/v2/folders',
                        json=payload,
                        timeout=30
                    )

                    if response.status_code in (200, 201):
                        folder_id = response.json()['id']
                        print(f"  ‚úì Created folder: {title} (ID: {folder_id})")
                        return folder_id
                    else:
                        print(f"  ‚úó Failed to create folder '{title}': {response.status_code} - {response.text}")
                        return None

                except Exception as e:
                    print(f"  ‚úó Error creating folder '{title}': {e}")
                    return None

            def ensure_folder_exists(self, folder_path: Path, parent_id: str) -> Optional[str]:
                """Ensure a folder exists in Confluence, creating it if necessary"""
                # Check cache first
                cache_key = str(folder_path)
                if cache_key in self.folder_cache:
                    return self.folder_cache[cache_key]

                # Get folder title from path
                folder_name = folder_path.name
                folder_title = folder_name.replace('_', ' ').replace('-', ' ').title()

                # Check if folder already exists
                folder_id = self.find_folder_by_title(folder_title, parent_id)

                if not folder_id:
                    # Try to create folder
                    folder_id = self.create_folder(folder_title, parent_id)

                    # If creation failed with 400 (folder already exists), try to find it again
                    # This handles race conditions and cases where the folder wasn't found initially
                    if not folder_id:
                        print(f"  Retrying folder search: {folder_title}")
                        folder_id = self.find_folder_by_title(folder_title, parent_id)

                # Cache the result
                if folder_id:
                    self.folder_cache[cache_key] = folder_id

                return folder_id

            def find_page_by_title(self, space_key: str, title: str, parent_id: Optional[str] = None) -> Optional[str]:
                """Find page ID by title in space using CQL query"""
                try:
                    # Build CQL query
                    cql = f'space = "{space_key}" AND title = "{title}"'
                    if parent_id:
                        cql += f' AND parent = {parent_id}'

                    response = self.session.get(
                        f'{CONFLUENCE_URL}/rest/api/content/search',
                        params={'cql': cql, 'limit': 1},
                        timeout=30
                    )

                    if response.status_code == 200:
                        results = response.json().get('results', [])
                        if results:
                            page_id = results[0]['id']
                            print(f"  Found existing page: {title} (ID: {page_id})")
                            return page_id
                    return None
                except Exception as e:
                    print(f"  Warning: Error searching for page '{title}': {e}")
                    return None

            def get_page_version(self, page_id: str) -> int:
                """Get current version of a page"""
                try:
                    response = self.session.get(
                        f'{CONFLUENCE_URL}/rest/api/content/{page_id}',
                        params={'expand': 'version'},
                        timeout=30
                    )
                    if response.status_code == 200:
                        return response.json()['version']['number']
                    return 1
                except Exception as e:
                    print(f"  Warning: Error getting page version: {e}")
                    return 1

            def extract_frontmatter(self, content: str) -> Tuple[Dict, str]:
                """Extract YAML frontmatter from Markdown content"""
                if not content.startswith('---'):
                    return {}, content

                try:
                    parts = content.split('---', 2)
                    if len(parts) >= 3:
                        frontmatter = yaml.safe_load(parts[1])
                        markdown_content = parts[2].strip()
                        return frontmatter or {}, markdown_content
                except Exception as e:
                    print(f"  Warning: Failed to parse frontmatter: {e}")

                return {}, content

            def get_page_title(self, file_path: Path, content: str) -> str:
                """Extract page title from frontmatter or filename"""
                if TITLE_FROM_FRONTMATTER:
                    frontmatter, _ = self.extract_frontmatter(content)
                    if 'title' in frontmatter:
                        return frontmatter['title']

                # Fallback to filename without extension, replacing _ and - with spaces
                return file_path.stem.replace('_', ' ').replace('-', ' ').title()

            def markdown_to_confluence(self, markdown_content: str) -> str:
                """Convert Markdown to Confluence Storage Format"""
                # Remove frontmatter if present
                _, clean_markdown = self.extract_frontmatter(markdown_content)

                # Use md2cf's ConfluenceRenderer
                renderer = ConfluenceRenderer()
                md = mistune.Markdown(renderer=renderer)
                confluence_html = md(clean_markdown)

                return confluence_html

            def extract_image_paths(self, markdown_content: str, file_path: Path) -> list:
                """Extract image paths from Markdown content"""
                import re

                images = []

                # Remove frontmatter first
                _, clean_markdown = self.extract_frontmatter(markdown_content)

                # Pattern for Markdown images: ![alt](path)
                md_pattern = r'!\[([^\]]*)\]\(([^)]+)\)'

                # Pattern for HTML images: <img src="path">
                html_pattern = r'<img[^>]+src=["\']([^"\']+)["\']'

                for match in re.finditer(md_pattern, clean_markdown):
                    alt_text = match.group(1)
                    image_path = match.group(2)

                    # Skip external URLs
                    if image_path.startswith(('http://', 'https://', '//')):
                        continue

                    images.append({
                        'alt': alt_text,
                        'path': image_path,
                        'type': 'markdown'
                    })

                for match in re.finditer(html_pattern, clean_markdown):
                    image_path = match.group(1)

                    # Skip external URLs
                    if image_path.startswith(('http://', 'https://', '//')):
                        continue

                    images.append({
                        'alt': '',
                        'path': image_path,
                        'type': 'html'
                    })

                # Resolve relative paths
                from urllib.parse import unquote

                base_dir = file_path.parent
                for img in images:
                    # Decode URL-encoded characters (e.g., %20 -> space, %2C -> comma)
                    decoded_path = unquote(img['path'])
                    img_path = Path(decoded_path)

                    # Handle absolute paths from repo root (starting with /)
                    if decoded_path.startswith('/'):
                        img['absolute_path'] = Path(decoded_path.lstrip('/'))
                    else:
                        # Relative path from markdown file location
                        img['absolute_path'] = (base_dir / img_path).resolve()

                    img['filename'] = img['absolute_path'].name

                return images

            def sanitize_filename(self, filename: str) -> str:
                """Sanitize filename for Confluence (remove spaces, special chars)"""
                import re

                # Split filename and extension
                parts = filename.rsplit('.', 1)
                name = parts[0]
                ext = parts[1] if len(parts) > 1 else ''

                # Replace spaces, commas, and special chars with hyphens
                name = re.sub(r'[^\w\-]', '-', name)
                # Remove multiple consecutive hyphens
                name = re.sub(r'-+', '-', name)
                # Remove leading/trailing hyphens
                name = name.strip('-')

                return f"{name}.{ext}" if ext else name

            def upload_attachment(self, page_id: str, file_path: Path) -> Optional[str]:
                """Upload an image as attachment to a Confluence page"""
                try:
                    if not file_path.exists():
                        print(f"  Warning: Image not found: {file_path}")
                        return None

                    # Sanitize filename for Confluence (spaces and special chars cause 415 errors)
                    original_filename = file_path.name
                    sanitized_filename = self.sanitize_filename(original_filename)

                    if original_filename != sanitized_filename:
                        print(f"    Sanitized filename: {original_filename} -> {sanitized_filename}")

                    # Check if attachment already exists
                    check_response = self.session.get(
                        f'{CONFLUENCE_URL}/rest/api/content/{page_id}/child/attachment',
                        params={'filename': sanitized_filename},
                        timeout=30
                    )

                    # Prepare file for upload
                    with open(file_path, 'rb') as f:
                        files = {'file': (sanitized_filename, f, self._get_mime_type(file_path))}

                        # Remove Content-Type header for multipart upload
                        headers = {k: v for k, v in self.session.headers.items() if k.lower() != 'content-type'}

                        if check_response.status_code == 200 and check_response.json().get('results'):
                            # Update existing attachment
                            attachment_id = check_response.json()['results'][0]['id']
                            response = self.session.post(
                                f'{CONFLUENCE_URL}/rest/api/content/{page_id}/child/attachment/{attachment_id}/data',
                                files=files,
                                headers=headers,
                                auth=self.session.auth,
                                timeout=60
                            )
                        else:
                            # Create new attachment
                            response = self.session.post(
                                f'{CONFLUENCE_URL}/rest/api/content/{page_id}/child/attachment',
                                files=files,
                                headers=headers,
                                auth=self.session.auth,
                                timeout=60
                            )

                    if response.status_code in (200, 201):
                        print(f"  ‚úì Uploaded image: {sanitized_filename}")
                        return sanitized_filename
                    else:
                        print(f"  ‚úó Failed to upload {sanitized_filename}: {response.status_code}")
                        return None

                except Exception as e:
                    print(f"  ‚úó Error uploading {file_path}: {e}")
                    return None

            def _get_mime_type(self, file_path: Path) -> str:
                """Get MIME type for image file"""
                extension = file_path.suffix.lower()
                mime_types = {
                    '.png': 'image/png',
                    '.jpg': 'image/jpeg',
                    '.jpeg': 'image/jpeg',
                    '.gif': 'image/gif',
                    '.svg': 'image/svg+xml',
                    '.webp': 'image/webp',
                    '.bmp': 'image/bmp',
                }
                return mime_types.get(extension, 'application/octet-stream')

            def update_image_references(self, confluence_html: str, images: list, uploaded_filenames: dict) -> str:
                """Update image references in Confluence HTML to point to attachments"""
                import re
                from urllib.parse import quote

                updated_html = confluence_html

                for img in images:
                    original_path = img['path']
                    original_filename = img['filename']

                    # Check if image was successfully uploaded (maps original -> sanitized)
                    if original_filename not in uploaded_filenames:
                        continue

                    # Get the sanitized filename that was actually uploaded
                    sanitized_filename = uploaded_filenames[original_filename]

                    # Confluence attachment reference format (must be inside ac:image tags)
                    attachment_ref = f'<ri:attachment ri:filename="{sanitized_filename}" />'

                    # Try multiple variations of the path to catch all encodings
                    path_variations = [
                        original_path,                           # Original: ./image name.png
                        quote(original_path),                    # URL encoded: ./image%20name.png
                        original_path.replace(' ', '%20'),       # Space to %20: ./image%20name.png
                        re.escape(original_path),                # Escaped for regex
                        re.escape(quote(original_path)),         # Escaped + encoded
                    ]

                    # Remove duplicates
                    path_variations = list(set(path_variations))

                    # Try to replace with each variation
                    for path_var in path_variations:
                        # Pattern 1: ri:url tags inside ac:image (created by md2cf)
                        # <ac:image><ri:url ri:value="path" /></ac:image>
                        # We want to keep the ac:image wrapper and just replace ri:url
                        pattern1 = f'(<ac:image[^>]*>)\\s*<ri:url ri:value="{path_var}"\\s*/>\\s*(</ac:image>)'
                        replacement1 = f'\\g<1>{attachment_ref}\\g<2>'
                        updated_html = re.sub(pattern1, replacement1, updated_html, flags=re.IGNORECASE)

                        # Pattern 2: ri:url without ac:image wrapper
                        pattern2 = f'<ri:url ri:value="{path_var}"\\s*/>'
                        replacement2 = f'<ac:image>{attachment_ref}</ac:image>'
                        updated_html = re.sub(pattern2, replacement2, updated_html, flags=re.IGNORECASE)

                        # Pattern 3: ri:url with flexible quotes
                        pattern3 = f'(<ac:image[^>]*>)\\s*<ri:url ri:value=["\']?{path_var}["\']?\\s*/>\\s*(</ac:image>)'
                        replacement3 = f'\\g<1>{attachment_ref}\\g<2>'
                        updated_html = re.sub(pattern3, replacement3, updated_html, flags=re.IGNORECASE)

                        # Pattern 4: HTML img tags
                        pattern4 = f'<img[^>]*src=["\']?{path_var}["\']?[^>]*>'
                        replacement4 = f'<ac:image>{attachment_ref}</ac:image>'
                        updated_html = re.sub(pattern4, replacement4, updated_html, flags=re.IGNORECASE)

                    # Fallback: Search for any ri:url that contains the original filename
                    # This catches cases where the path was heavily transformed
                    filename_pattern = f'(<ac:image[^>]*>)?\\s*<ri:url[^>]*ri:value="[^"]*{re.escape(original_filename)}"[^>]*/>(\\s*</ac:image>)?'
                    replacement = f'<ac:image>{attachment_ref}</ac:image>'
                    updated_html = re.sub(filename_pattern, replacement, updated_html, flags=re.IGNORECASE)

                return updated_html

            def create_page(self, space_key: str, title: str, body: str, parent_id: str) -> Optional[str]:
                """Create a new Confluence page"""
                try:
                    payload = {
                        'type': 'page',
                        'title': title,
                        'space': {'key': space_key},
                        'body': {
                            'storage': {
                                'value': body,
                                'representation': 'storage'
                            }
                        },
                        'ancestors': [{'id': parent_id}]
                    }

                    response = self.session.post(
                        f'{CONFLUENCE_URL}/rest/api/content',
                        json=payload,
                        timeout=30
                    )

                    if response.status_code == 200:
                        page_id = response.json()['id']
                        print(f"  ‚úì Created page: {title} (ID: {page_id})")
                        return page_id
                    else:
                        error_msg = response.json().get('message', response.text)
                        print(f"  ‚úó Failed to create page: {error_msg}")
                        return None

                except Exception as e:
                    print(f"  ‚úó Error creating page: {e}")
                    return None

            def update_page(self, page_id: str, title: str, body: str) -> bool:
                """Update an existing Confluence page"""
                try:
                    # Get current version
                    current_version = self.get_page_version(page_id)

                    payload = {
                        'version': {'number': current_version + 1},
                        'title': title,
                        'type': 'page',
                        'body': {
                            'storage': {
                                'value': body,
                                'representation': 'storage'
                            }
                        }
                    }

                    response = self.session.put(
                        f'{CONFLUENCE_URL}/rest/api/content/{page_id}',
                        json=payload,
                        timeout=30
                    )

                    if response.status_code == 200:
                        print(f"  ‚úì Updated page: {title} (ID: {page_id})")
                        return True
                    else:
                        error_msg = response.json().get('message', response.text)
                        print(f"  ‚úó Failed to update page: {error_msg}")
                        return False

                except Exception as e:
                    print(f"  ‚úó Error updating page: {e}")
                    return False

            def add_label_to_page(self, page_id: str, label: str) -> bool:
                """Add a label to a page"""
                try:
                    payload = {
                        'prefix': 'global',
                        'name': label
                    }

                    response = self.session.post(
                        f'{CONFLUENCE_URL}/rest/api/content/{page_id}/label',
                        json=[payload],
                        timeout=30
                    )

                    return response.status_code in [200, 201]
                except Exception as e:
                    print(f"  Warning: Error adding label: {e}")
                    return False

            def mark_deprecated(self, file_path: Path) -> bool:
                """Mark a page as deprecated by adding label and warning banner"""
                try:
                    # Read file to get title
                    with open(file_path, 'r', encoding='utf-8') as f:
                        content = f.read()

                    title = self.get_page_title(file_path, content)

                    # Find the page
                    page_id = self.find_page_by_title(SPACE_KEY, title)

                    if not page_id:
                        print(f"  Warning: Page not found for deleted file: {file_path}")
                        return False

                    # Get current page content
                    response = self.session.get(
                        f'{CONFLUENCE_URL}/rest/api/content/{page_id}',
                        params={'expand': 'body.storage,version'},
                        timeout=30
                    )

                    if response.status_code != 200:
                        return False

                    page_data = response.json()
                    current_body = page_data['body']['storage']['value']
                    current_version = page_data['version']['number']

                    # Prepend deprecation warning
                    deprecation_banner = '''
        <ac:structured-macro ac:name="warning">
          <ac:rich-text-body>
            <p><strong>‚ö†Ô∏è Esta p√°gina ha sido deprecada y ya no se mantiene.</strong></p>
            <p>El archivo fuente ha sido eliminado del repositorio.</p>
          </ac:rich-text-body>
        </ac:structured-macro>
        '''

                    # Only add banner if not already present
                    if '‚ö†Ô∏è Esta p√°gina ha sido deprecada' not in current_body:
                        new_body = deprecation_banner + current_body

                        # Update page
                        payload = {
                            'version': {'number': current_version + 1, 'minorEdit': True},
                            'title': title,
                            'type': 'page',
                            'body': {
                                'storage': {
                                    'value': new_body,
                                    'representation': 'storage'
                                }
                            }
                        }

                        update_response = self.session.put(
                            f'{CONFLUENCE_URL}/rest/api/content/{page_id}',
                            json=payload,
                            timeout=30
                        )

                        if update_response.status_code != 200:
                            print(f"  Warning: Failed to update page with deprecation banner")

                    # Add deprecated label
                    self.add_label_to_page(page_id, 'deprecated')

                    print(f"  ‚úì Marked as deprecated: {title}")
                    return True

                except Exception as e:
                    print(f"  ‚úó Error marking as deprecated: {e}")
                    return False

            def _should_exclude(self, file_path: Path) -> bool:
                """Check if a file should be excluded from sync"""
                excluded_patterns = [
                    '.github',      # GitHub workflows and config
                    '.git',         # Git directory
                    'node_modules', # Node dependencies
                    '__pycache__',  # Python cache
                    '.venv',        # Python virtual env
                    'venv',         # Python virtual env
                    '.DS_Store',    # macOS files
                ]

                # Check if any part of the path matches excluded patterns
                path_str = str(file_path)
                for pattern in excluded_patterns:
                    if f'/{pattern}/' in path_str or path_str.startswith(f'{pattern}/') or f'\\{pattern}\\' in path_str:
                        return True

                return False

            def get_parent_folder_for_file(self, file_path: Path, root_parent_id: str) -> Optional[str]:
                """Get or create parent folder for a file based on its path"""
                docs_path = Path(DOCS_FOLDER if DOCS_FOLDER not in ('.', '', './') else '.')

                try:
                    relative_path = file_path.relative_to(docs_path)
                except ValueError:
                    return root_parent_id

                # Get parent folder path
                parent_folder = relative_path.parent

                # If file is directly in docs folder, use root parent
                if str(parent_folder) == '.':
                    return root_parent_id

                # Build folder hierarchy
                current_parent_id = root_parent_id
                for folder_part in parent_folder.parts:
                    folder_path = docs_path / Path(*parent_folder.parts[:parent_folder.parts.index(folder_part) + 1])
                    folder_id = self.ensure_folder_exists(folder_path, current_parent_id)

                    if not folder_id:
                        print(f"  Warning: Could not create folder for {folder_path}")
                        return root_parent_id

                    current_parent_id = folder_id

                return current_parent_id

            def sync_file(self, file_path: Path, root_parent_id: str) -> bool:
                """Sync a single Markdown file to Confluence, including images"""
                try:
                    print(f"\nProcessing: {file_path}")

                    # Read file content
                    with open(file_path, 'r', encoding='utf-8') as f:
                        content = f.read()

                    # Extract title (from frontmatter or filename) - NO folder prefix
                    title = self.get_page_title(file_path, content)

                    # Get the parent folder ID for this file (creating folders as needed)
                    parent_id = self.get_parent_folder_for_file(file_path, root_parent_id)

                    # Extract image paths from Markdown
                    images = self.extract_image_paths(content, file_path)
                    if images:
                        print(f"  Found {len(images)} image(s) to upload")

                    # Convert Markdown to Confluence Storage Format
                    confluence_content = self.markdown_to_confluence(content)

                    # Add source metadata comment
                    source_comment = f'<!-- Synced from: {file_path} -->\n'
                    confluence_content = source_comment + confluence_content

                    # Check if page exists
                    page_id = self.find_page_by_title(SPACE_KEY, title, parent_id)

                    if page_id:
                        # Update existing page
                        success = self.update_page(page_id, title, confluence_content)
                    else:
                        # Create new page
                        page_id = self.create_page(SPACE_KEY, title, confluence_content, parent_id)
                        success = page_id is not None

                    if not success:
                        failed_pages.append({
                            'file': str(file_path),
                            'error': 'Failed to create/update page'
                        })
                        return False

                    # Upload images as attachments and update references
                    if images and page_id:
                        print(f"  Uploading {len(images)} image(s)...")
                        uploaded_filenames = {}  # Maps original filename -> sanitized filename

                        for img in images:
                            img_path = img['absolute_path']
                            original_filename = img_path.name
                            print(f"    - Image path: {img['path']} -> {img_path}")
                            sanitized_filename = self.upload_attachment(page_id, img_path)
                            if sanitized_filename:
                                # Map original filename to sanitized filename
                                uploaded_filenames[original_filename] = sanitized_filename

                        # Update page content with correct attachment references
                        if uploaded_filenames:
                            print(f"  Updating page with {len(uploaded_filenames)} attachment reference(s)...")
                            updated_content = self.update_image_references(
                                confluence_content,
                                images,
                                uploaded_filenames
                            )

                            # Update page again with corrected image references
                            if updated_content != confluence_content:
                                print(f"  ‚úì Image references updated successfully")
                                self.update_page(page_id, title, updated_content)
                            else:
                                print(f"  ‚ö† Warning: No image references were updated in HTML")
                                print(f"    This might indicate the conversion format changed")
                                print(f"    Original images: {[img['path'] for img in images]}")

                    # Get page URL
                    page_url = f"{CONFLUENCE_URL}/pages/viewpage.action?pageId={page_id}"

                    synced_pages.append({
                        'file': str(file_path),
                        'title': title,
                        'page_id': page_id,
                        'url': page_url
                    })

                    return True

                except Exception as e:
                    error_msg = f"Failed to sync {file_path}: {str(e)}"
                    print(f"  ‚úó {error_msg}")

                    failed_pages.append({
                        'file': str(file_path),
                        'error': str(e)
                    })

                    # Write to error file
                    with open(ERROR_FILE, 'a') as ef:
                        ef.write(f"{error_msg}\n")

                    return False

            def sync_folder(self, folder_path: Path, parent_id: str):
                """Sync all Markdown files in a folder, creating Confluence folders as needed"""
                print(f"\n=== Confluence Documentation Sync ===")
                print(f"Mode: {SYNC_MODE}")
                print(f"Docs folder: {DOCS_FOLDER}")
                print(f"Space: {SPACE_KEY}")
                print(f"Parent folder/page ID: {parent_id}")

                # Process deleted files first
                if DELETED_FILES:
                    print(f"\n--- Processing Deleted Files ---")
                    for deleted_file in DELETED_FILES:
                        if deleted_file:
                            file_path = Path(deleted_file)
                            # Note: File no longer exists, so we need to reconstruct info
                            # For now, just log it - full deprecation would need a mapping file
                            print(f"  Note: File deleted: {deleted_file}")
                            print(f"  To mark as deprecated, page must be found by title pattern")

                # Get files to sync
                if SYNC_MODE == 'changed' and CHANGED_FILES:
                    # Only sync changed files
                    files_to_sync = [
                        Path(f) for f in CHANGED_FILES
                        if f.endswith('.md') and Path(f).exists() and not self._should_exclude(Path(f))
                    ]
                    print(f"\n--- Syncing Changed Files ({len(files_to_sync)}) ---")
                else:
                    # Sync all files, excluding .github and other system folders
                    all_files = folder_path.glob('**/*.md')
                    files_to_sync = [f for f in all_files if not self._should_exclude(f)]
                    print(f"\n--- Syncing All Files ({len(files_to_sync)}) ---")

                if not files_to_sync:
                    print("No files to sync")
                    return

                # Sync each file, creating Confluence folders as needed to preserve hierarchy
                # GitHub folders ‚Üí Confluence folders (real folders, not pages)
                # GitHub .md files ‚Üí Confluence pages (inside folders)
                for file_path in files_to_sync:
                    self.sync_file(file_path, parent_id)

        def main():
            """Main sync execution"""
            try:
                # Initialize sync
                sync = ConfluenceSync()

                # Sync folder (support root directory with "." or empty string)
                docs_folder_normalized = DOCS_FOLDER.strip()
                if docs_folder_normalized in ('.', '', './'):
                    docs_path = Path('.')
                    print(f"üìÅ Syncing from repository root (excluding .github and system folders)")
                else:
                    docs_path = Path(DOCS_FOLDER)
                    if not docs_path.exists():
                        raise Exception(f"Documentation folder not found: {DOCS_FOLDER}")
                    print(f"üìÅ Syncing from folder: {DOCS_FOLDER}")

                sync.sync_folder(docs_path, PARENT_PAGE_ID)

                # Output results
                print(f"\n=== Sync Complete ===")
                print(f"‚úì Synced: {len(synced_pages)} page(s)")
                print(f"‚úó Failed: {len(failed_pages)} page(s)")

                # Set GitHub Actions outputs
                if GITHUB_OUTPUT:
                    with open(GITHUB_OUTPUT, 'a') as f:
                        f.write(f"synced_pages={len(synced_pages)}\n")
                        f.write(f"failed_pages={len(failed_pages)}\n")

                        # Output URLs as JSON array
                        urls = [p['url'] for p in synced_pages]
                        f.write(f"confluence_urls={json.dumps(urls)}\n")

                # Exit with error if any failures
                if failed_pages:
                    print("\nSome pages failed to sync. Check errors above.")
                    sys.exit(1)

            except Exception as e:
                error_msg = f"Sync failed: {str(e)}"
                print(f"\n‚úó {error_msg}", file=sys.stderr)

                with open(ERROR_FILE, 'a') as ef:
                    ef.write(f"{error_msg}\n")

                sys.exit(1)

        if __name__ == '__main__':
            main()
        PYTHON_SCRIPT_END
