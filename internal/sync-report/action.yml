name: "Sync Report"
description: "Reports sync result back to source PR"
inputs:
  github_token:
    description: "GitHub token for API calls"
    required: true
  gitops_pr_url:
    description: "URL of the created GitOps PR"
    required: false
  sync_branch:
    description: "Source branch that was synced"
    required: true
  target_env:
    description: "Target environment (staging/prod)"
    required: true
  error_file_path:
    description: "Path to error file if any"
    required: false
    default: ""

runs:
  using: "composite"
  steps:
    - name: Ensure Comment Token
      shell: bash
      run: |
        if [ -z "${COMMENT_TOKEN:-}" ]; then
          echo "COMMENT_TOKEN=${{ inputs.github_token }}" >> $GITHUB_ENV
        fi
        echo "Token disponible para comentario"

    - name: Report Result
      uses: actions/github-script@v7
      env:
        COMMENT_TOKEN: ${{ env.COMMENT_TOKEN }}
        ERRFILE: ${{ inputs.error_file_path }}
        GITOPS_PR_URL: ${{ inputs.gitops_pr_url }}
        SYNC_BRANCH: ${{ inputs.sync_branch }}
        TARGET_ENV: ${{ inputs.target_env }}
      with:
        github-token: ${{ env.COMMENT_TOKEN }}
        script: |
          console.log('=== Script iniciado ===');
          core.info('=== Iniciando script de reporte ===');
          
          try {
            core.info(`COMMENT_TOKEN definido: ${!!process.env.COMMENT_TOKEN}`);
            core.info(`ERRFILE: ${process.env.ERRFILE || '(no definido)'}`);
            core.info(`GITOPS_PR_URL: ${process.env.GITOPS_PR_URL || '(no definido)'}`);
            core.info(`SYNC_BRANCH: ${process.env.SYNC_BRANCH || '(no definido)'}`);
            core.info(`TARGET_ENV: ${process.env.TARGET_ENV || '(no definido)'}`);
            
            if (!process.env.COMMENT_TOKEN) {
              core.error('ERROR: COMMENT_TOKEN no está definido. No se puede publicar comentario.');
              core.error('Variables de entorno disponibles: ' + Object.keys(process.env).filter(k => k.includes('TOKEN') || k.includes('COMMENT')).join(', '));
              return;
            }
            
            const fs = require('fs');
            
            // Obtener el cuerpo del comentario de manera más robusta
            const commentBody = (context.payload?.comment?.body || 
                               context.payload?.issue?.body || 
                               '').toString();
            
            core.info(`Comentario recibido (longitud: ${commentBody.length}): ${commentBody.substring(0, Math.min(100, commentBody.length))}`);
            
            if (/^:white_check_mark:|^:x:|^Configuración sincronizada|^No se pudo sincronizar/i.test(commentBody)) {
              core.info('El comentario parece ser una respuesta automática. No se publicará respuesta para evitar loops.');
              return;
            }
            
            const errFile = process.env.ERRFILE || '';
            let hasError = false;
            
            if (errFile && fs.existsSync(errFile)) {
              try {
                const errorContent = fs.readFileSync(errFile, 'utf8').trim();
                hasError = errorContent.length > 0;
                if (hasError) {
                  core.info(`Error detectado en archivo: ${errorContent.substring(0, 200)}...`);
                }
              } catch (err) {
                core.warning(`No se pudo leer el archivo de error: ${err.message}`);
              }
            }
            
            const prUrl = process.env.GITOPS_PR_URL || '';
            const syncBranch = process.env.SYNC_BRANCH || '(rama no disponible)';
            const targetEnv = process.env.TARGET_ENV || '(entorno no disponible)';
            let body = '';
            
            if (hasError) {
              const errorContent = fs.readFileSync(errFile, 'utf8');
              body = ':x: La sincronización de la rama "' + syncBranch + '" hacia "' + targetEnv + '" falló.\n\n```\n' +
                errorContent + '\n```\n';
              if (prUrl) body += 'Se alcanzó a crear la PR en GitOps: ' + prUrl + '\n';
            } else if (prUrl) {
              body = ':white_check_mark: Configuración de la rama "' + syncBranch + '" sincronizada en "' + targetEnv + '".\n' +
                'PR en GitOps: ' + prUrl + '\n';
            } else {
              body = ':white_check_mark: Configuración sincronizada exitosamente.\n';
            }

            // Obtener el número de issue/PR de manera más robusta
            const issueNumber = context.issue?.number ||
              context.payload?.issue?.number ||
              context.payload?.pull_request?.number ||
              context.payload?.number;
            
            core.info(`Número de issue/PR detectado: ${issueNumber}`);
            
            if (!issueNumber) {
              core.warning('No se encontró número de PR/issue para comentar.');
              core.info('Context payload keys: ' + Object.keys(context.payload || {}).join(', '));
              core.info('Context issue: ' + JSON.stringify(context.issue || {}));
              return;
            }

            const repoOwner = context.repo?.owner || context.payload?.repository?.owner?.login || context.repository?.owner?.login;
            const repoName = context.repo?.repo || context.payload?.repository?.name || context.repository?.name;
            
            if (!repoOwner || !repoName) {
              core.error('No se pudo determinar el owner/repo del repositorio.');
              return;
            }

            core.info(`Comentando en ${repoOwner}/${repoName}#${issueNumber}`);
            
            await github.rest.issues.createComment({
              owner: repoOwner,
              repo: repoName,
              issue_number: issueNumber,
              body
            });
            
            core.info('Comentario publicado exitosamente.');
          } catch (error) {
            core.error('Error al publicar comentario:');
            core.error(error.message);
            core.error(error.stack);
            throw error;
          }

